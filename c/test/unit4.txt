#MAX HEAP
insertion

typedef struct node
{
    int key;
}element;

we r using the array representation of trees is this so no need link and all..
element heap[1000];
int *n;
void insert_maxheap(element item,int*n)
{
    int i ;
    if(HEAPFULL(*n))
    {
        fprintf(stderr,"HEAP full");
    }
    i=++(*n);//this is where the new node is currently for now.. then it will be compared to its parent if it is larger it will be swapped
    while(i!=1 && (item.key > heap[i/2].key))//till i does not reach root && from the last node it keeps on comparing
    {
        heap[i]=heap[i/2]; //bringing the smaller element down
        i/=2;
    }
    heap[i]=item;// after all the smaller elements are down putting the element where it belongs
}
void insert_maxheap(element item,int*n)
{
    int i;
    if(ISFULL(*n))
    {
        stderr
        exit(1)
    }
    i = ++(*n);
    while(i!=1 && item.key> heap[i/2].key)//while item is greater than its parent
    {
        heap[i]=heap[i/2];
        i/=2;
    }
    heap[i]=item;
}

deletion
IN MAX HEAP ONLY DELETION OF ROOT NODE IS THERE

void delete_maxheap(int *n)
{
    int child ,parent;
    element temp,item;
    child=2;
    parent=1;
    if(HEAPEMPTY(*n))
    {
        printf(stderr,Heap full);
        exit(1);
    }
    item = heap[1];//storing the root node it return it in last
    temp = heap[(*n)--]; //taking the last node to put it at top initially and traversing it down;
    while(child<= *n)
    {
        if(child< *n && heap[child].key<heap[child+1].key)//comparing the left and right children to see which is larger then the larger one will be taken and swapped with current root()
            child++;
        if(temp.key >=heap[child].key)break;
        heap[parent]=heap[child];
        parent=child;
        child*=2
    }
    heap[parent]=temp;
    return item;
}
void delete_maxheap(int *n)
{
    int child,parent;
    element temp,item;
    if(ISEMPTY(heap))
    {
        exit(1);
    }
    item = heap[1];
    temp = heap[*n--];
    parent=1;
    child=2;
    while(child<=*n)
    {
        if(child<*n && heap[child].key<heap[child+1].key)
            child++;
        if(temp.key>heap[child])break;
        heap[parent]=heap[child];
        parent=child;
        child*=2;
    }
    heap[parent]=temp;
    return item;
}
#### binary search tree search ####
tree_pointer is used in bst
struct tree{
    int data;
    struct tree* left_child;
    struct tree* right_child;
}
typedef struct node* tree_pointer;
tree_pointer search(tree_pointer root,int key)
{
    if(!root)return null;
    if(root->data==key)return root;
    else if(root->data>key)
    {
        search(root->left_child,key);
    }
    else
    {
        search(root->right_child,key);
    }
}


#### inserting into a binary search tree ####
uses a modified search function which returns NULL is the key is found or null if tree is empty.
if condition phir ptr ko saja dhaja ke daal dete h..
void insert_node(tree_pointer *node,int num)
{
    tree_pointer ptr,temp=modifiedsearch(*node,num);
    if(temp || !(*node)) //it will run if node is empty itll create new.. but if nodes are there and temp is null means it means that node is already there so it wont run
    {
        ptr = (tree_pointer)malloc(sizeof(struct tree));
        if(IS_FULL(ptr))
        {
            fprintf(stderr,"err");
        }
        ptr->data = num;
        ptr->left_child=ptr->right_child=NULL;
        if(*node)
        {
            if(num>temp->data)
            {
                temp->right_child=ptr;
            }
            else temp->left_child=ptr;
        }
        else
        *node = ptr //when the tree is empty

    }
}
####threaded binary trees####
threaded_pointer insucc(threaded_pointer tree)
{
    to find the inorder successor of tree in a threaded binary tree
    threaded_pointer temp;
    temp = tree->right_child;
    if(!tree->right_thread)
    {
        while(!tree->left_thread)
        {
            temp = temp->left_child
        }
        
    }
    return temp;
}