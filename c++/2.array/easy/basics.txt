

// to find the largest
// nothing fancy
// brute force will be to sort it and last number
// optimal will be to do a pass

// to find second largest
// brute force will be to sort and do a pass from back to find the second largest
// better will be to do two passes , one for largest and other for second largest
// optimal will be to do a pass , if largest gets updated then update the second largest as the previous largest


// to see if it is sorted or not, simple one pass nothing complex



// remove duplicates from a SORTED array
// we will maintain a variable 
// then increment the varaible to keep storeing new and ignore duplicates
// similar approach we use in move zeros to the last 



class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        
        if (n <= 1) {
            return n;
        }
        
        int ans = 1; // The first element is always unique
        
        for (int i = 1; i < n; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[ans] = nums[i]; // Overwrite duplicates
                ans++;
            }
        }
        
        return ans;
        
    }
};

//  nums.erase(nums.begin()+3) remove that element did not work

// nums.clear is to remove the whole array





// left rotate an array by one place
// store the first number , then left shift all other by one pass
// you can store the first k elements 
// then shift the rest to starting 
// then put back the stored array at last
!!!!!! important thing is to k=k%n if k>n;

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        
        vector<int> ans;
        int n=nums.size();
        if(n<=1)return ;
        if(k>=n)k%=n;
        for(int i=n-k;i<n;i++)
        {
            ans.push_back(nums[i]);
        }
        for(int i=0;i<n-k;i++)
        {
            ans.push_back(nums[i]);
        }
        for(int i=0;i<n;i++)
        {
            nums[i]=ans[i];
        }
        // return ans;
    }
};


// union  of 2 arrays
// using set 
// time complexity is n1logn+n2logn + O(n1+n2) where n is size of set which is varying
// space complexity = O(n1+n2) + O(n1+n2)
// 